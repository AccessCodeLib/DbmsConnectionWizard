NDSummary.OnToolTipsLoaded("VisualBasicClass:data.dao.DaoHandler",{1:"<div class=\"NDToolTip TClass LVisualBasic\"><div class=\"TTSummary\">/** \\author&nbsp; Josef Poetzl &lt;summary&gt; DAO-Zugriffsmethoden &lt;/summary&gt; &lt;remarks&gt;&lt;/remarks&gt; \\ingroup data_dao **/</div></div>",3:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype3\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Sub InitRecordsetEnumDefaultValues(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">Optional ByRef RecordsetType&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.RecordsetTypeEnum,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByRef Options&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.RecordsetOptionEnum,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByRef LockEdit&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.LockTypeEnum</td></tr></table></td><td class=\"PAfterParameters\">)</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Standardwerte für Recordset-Enums einstellen, welche verwendet werden, wenn Parameter nicht gesetzt werden können (z. B. in OpenRecordsetParamSQL2) &lt;/summary&gt; &lt;param name=&quot;RecordsetType&quot;&gt;Standardwert aus DAO.RecordsetTypeEnum&lt;/param&gt; &lt;param name=&quot;Options&quot;&gt;Standardwert aus DAO.RecordsetOptionEnum&lt;/param&gt; &lt;param name=&quot;LockEdit&quot;&gt;Standardwert aus DAO.LockTypeEnum&lt;/param&gt; &lt;remarks&gt;Wenn 0 eingestellt wird, kommt Standard von DAO zum Einsatz (0-Parameter werden als &quot;IsMissing&quot;-Variant-Wert an DAO weitergeben)&lt;/remarks&gt; **/</div></div>",62:"<div class=\"NDToolTip TProperty LVisualBasic\"><div class=\"TTSummary\">/** &lt;summary&gt; CurrentDbC-Variante &lt;/summary&gt; &lt;returns&gt;DAO.Database&lt;/returns&gt; &lt;remarks&gt; CurrentDbC-Variante, die zum Unterschied zur Original-Version von Michael Kaplan die DAO-Database-Referenz nicht automatisch auf Access.Application.CurrentDb setzt, sondern über ein Ereignis anfordert, falls noch keine Referenz vorhanden ist.&nbsp; Dadurch kann über die Hauptanwendung eine belibige Database-Referenz übergeben werden.&nbsp; (z. B. falls eine Temp-Datenbank als CurrentDb dienen soll)&lt;/remarks&gt; **/</div></div>",65:"<div class=\"NDToolTip TProperty LVisualBasic\"><div class=\"TTSummary\">/** &lt;summary&gt; Übergabe der DAO-Database-Referenz &lt;/summary&gt; &lt;param name=&quot;NewCurrentDb&quot;&gt;Database-Referenz, die als &quot;CurrentDb&quot; verwendet werden soll&lt;/param&gt; &lt;returns&gt;DAO.Database&lt;/returns&gt; &lt;remarks&gt;&lt;/remarks&gt; **/</div></div>",75:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype75\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function Execute(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal Query&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal Options&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.RecordsetOptionEnum</td></tr></table></td><td class=\"PAfterParameters\">) As Long</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; SQL-Anweisung ausführen &lt;/summary&gt; &lt;param name=&quot;CommandText&quot;&gt;SQL-Anweisung&lt;/param&gt; &lt;param name=&quot;Options&quot;&gt;&lt;/param&gt; &lt;returns&gt;Long (Anzahl der betroffenen Datensätze)&lt;/returns&gt; **/</div></div>",76:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype76\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function ExecuteParamSql(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal SqlText&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ParamArray QueryParams()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Long</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Sql-Anweisung mit Parametern ausführen &lt;/summary&gt; &lt;param name=&quot;SqlText&quot;&gt;SQL-Anweisung&lt;/param&gt; &lt;param name=&quot;ParamValues&quot;&gt;Parmeterwerte in passender Reihenfolge&lt;/param&gt; &lt;param name=&quot;QueryParams&quot;&gt; Werte in passender Reihenfolge als ParamArray oder als Array &lt;br/&gt; oder&lt;br/&gt; 2-dimensionales Parameter-Array (Array(n,1) ... x(n,0) = Parametername, x(n,1) = Parameterwert) ... erzeugbar mit GetParamDefArray oder GetNamedParamDefArray &lt;/param&gt; &lt;returns&gt;Long (Anzahl der betroffenen Datensätze)&lt;/returns&gt; &lt;remarks&gt; &lt;/remarks&gt; **/</div></div>",77:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype77\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function ExecuteQueryDefByName(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal QueryName&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ParamArray QueryParams()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Long</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Gespeicherte Abfrage (optional mit Parametern) ausführen &lt;/summary&gt; &lt;param name=&quot;QueryName&quot;&gt;Name der gespeicherten Abfrage (QueryDef)&lt;/param&gt; &lt;param name=&quot;QueryParams&quot;&gt; Werte in passender Reihenfolge als ParamArray oder als Array &lt;br/&gt; oder&lt;br/&gt; 2-dimensionales Parameter-Array (Array(n,1) ... x(n,0) = Parametername, x(n,1) = Parameterwert) ... erzeugbar mit GetParamDefArray oder GetNamedParamDefArray &lt;/param&gt; &lt;returns&gt;Long (Anzahl der betroffenen Datensätze)&lt;/returns&gt; &lt;remarks&gt; &lt;/remarks&gt; **/</div></div>",78:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype78\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function ExecuteQueryDef(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal QdfRef&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.QueryDef,</td></tr><tr><td class=\"PModifierQualifier first\">ParamArray QueryParams()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Long</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; QueryDef-Objekt mit Parameterwerten befüllen und anschließend ausführen &lt;/summary&gt; &lt;param name=&quot;Qdf&quot;&gt;QueryDef-Referenz&lt;/param&gt; &lt;param name=&quot;QueryParams&quot;&gt; Werte in passender Reihenfolge als ParamArray oder als Array &lt;br/&gt; oder&lt;br/&gt; 2-dimensionales Parameter-Array (Array(n,1) ... x(n,0) = Parametername, x(n,1) = Parameterwert) ... erzeugbar mit GetParamDefArray oder GetNamedParamDefArray &lt;/param&gt; &lt;returns&gt;Long (Anzahl der betroffenen Datensätze)&lt;/returns&gt; &lt;remarks&gt; &lt;/remarks&gt; **/</div></div>",79:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype79\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function ParamQueryDefByName(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal QueryName&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ParamArray QueryParams()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As DAO.QueryDef</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Gespeicherte Abfrage als QueryDef-Objekt ink. übergebenen Parameterwerten öffnen &lt;/summary&gt; &lt;param name=&quot;QueryName&quot;&gt;QueryDef-Name&lt;/param&gt; &lt;param name=&quot;QueryParams&quot;&gt; Werte in passender Reihenfolge als ParamArray oder als Array &lt;br/&gt; oder&lt;br/&gt; 2-dimensionales Parameter-Array (Array(n,1) ... x(n,0) = Parametername, x(n,1) = Parameterwert) ... erzeugbar mit GetParamDefArray oder GetNamedParamDefArray &lt;/param&gt; &lt;returns&gt;DAO.QueryDef&lt;/returns&gt; &lt;remarks&gt; &lt;/remarks&gt; **/</div></div>",80:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype80\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function ParamQueryDefSql(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal ParamSqlText&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ParamArray QueryParams()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As DAO.QueryDef</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Temporäres QueryDef-Objekt ink. übergebenen Parameterwerten öffnen &lt;/summary&gt; &lt;param name=&quot;ParamSqlText&quot;&gt;SQL-Anweisung für das temporäre QueryDef-Objekt&lt;/param&gt; &lt;param name=&quot;QueryParams&quot;&gt; Werte in passender Reihenfolge als ParamArray oder als Array &lt;br/&gt; oder&lt;br/&gt; 2-dimensionales Parameter-Array (Array(n,1) ... x(n,0) = Parametername, x(n,1) = Parameterwert) ... erzeugbar mit GetParamDefArray oder GetNamedParamDefArray &lt;/param&gt; &lt;returns&gt;DAO.QueryDef&lt;/returns&gt; &lt;remarks&gt; &lt;/remarks&gt; **/</div></div>",81:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype81\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function OpenRecordset(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal Source&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName\">String,</td><td></td><td class=\"last\"></td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal RecordsetType&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName\">DAO.RecordsetTypeEnum</td><td class=\"PDefaultValueSeparator\">&nbsp;=&nbsp;</td><td class=\"PDefaultValue last\">dbOpenDynaset,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal RecordsetOptions&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName\">DAO.RecordsetOptionEnum</td><td class=\"PDefaultValueSeparator\">&nbsp;=&nbsp;</td><td class=\"PDefaultValue last\">DAO.RecordsetOptionEnum.dbSeeChanges,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal LockEdit&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName\">DAO.LockTypeEnum</td><td></td><td class=\"last\"></td></tr></table></td><td class=\"PAfterParameters\">) As DAO.Recordset</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Recordset öffnen &lt;/summary&gt; &lt;param name=&quot;Source&quot;&gt;SQL-Anweisung oder Tabllen- bzw. Abfragename&lt;/param&gt; &lt;param name=&quot;RecordsetType&quot;&gt;DAO.RecordsetTypeEnum (Standard: dbOpenDynaset)&lt;/param&gt; &lt;param name=&quot;RecordsetOptions&quot;&gt;DAO.RecordsetOptionEnum (Standard: dbSeeChanges)&lt;/param&gt; &lt;param name=&quot;LockEdit&quot;&gt;DAO.LockTypeEnum (Standard: dbOptimistic)&lt;/param&gt; &lt;returns&gt;DAO.Recordset&lt;/returns&gt; &lt;remarks&gt;&lt;/remarks&gt; **/</div></div>",82:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype82\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function OpenRecordsetParamSql(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal ParamSqlText&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal RecordsetType&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.RecordsetTypeEnum,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal Options&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.RecordsetOptionEnum,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal LockEdit&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.LockTypeEnum,</td></tr><tr><td class=\"PModifierQualifier first\">ParamArray QueryParams()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As DAO.Recordset</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Parameter-SQL-Anweisung öffnen (verwendet temporäres QueryDef) &lt;/summary&gt; &lt;param name=&quot;ParamSqlText&quot;&gt;SQL-Anweisung mit Parameter (Parameters-Deklaration)&lt;/param&gt; &lt;param name=&quot;RecordsetType&quot;&gt;DAO.RecordsetTypeEnum (Standard: dbOpenDynaset)&lt;/param&gt; &lt;param name=&quot;RecordsetOptions&quot;&gt;DAO.RecordsetOptionEnum (Standard: dbSeeChanges)&lt;/param&gt; &lt;param name=&quot;LockEdit&quot;&gt;DAO.LockTypeEnum (Standard: dbOptimistic)&lt;/param&gt; &lt;param name=&quot;QueryParams&quot;&gt; Werte in passender Reihenfolge als ParamArray oder als Array &lt;br/&gt; oder&lt;br/&gt; 2-dimensionales Parameter-Array (Array(n,1) ... x(n,0) = Parametername, x(n,1) = Parameterwert) ... erzeugbar mit GetParamDefArray oder GetNamedParamDefArray &lt;/param&gt; &lt;returns&gt;DAO.Recordset&lt;/returns&gt; &lt;remarks&gt;&lt;/remarks&gt; **/</div></div>",83:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype83\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function OpenRecordsetParamSql2(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal ParamSqlText&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ParamArray QueryParams()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As DAO.Recordset</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Parameter-SQL-Anweisung öffnen (wie OpenRecordsetParamSQL, nur mit Standardwerten für RecordsetType, RecordsetOptions u. LockEdit) &lt;/summary&gt; &lt;param name=&quot;ParamSqlText&quot;&gt;SQL-Anweisung mit Parameter (Parameters-Deklaration)&lt;/param&gt; &lt;param name=&quot;QueryParams&quot;&gt; Werte in passender Reihenfolge als ParamArray oder als Array &lt;br/&gt; oder&lt;br/&gt; 2-dimensionales Parameter-Array (Array(n,1) ... x(n,0) = Parametername, x(n,1) = Parameterwert) ... erzeugbar mit GetParamDefArray oder GetNamedParamDefArray &lt;/param&gt; &lt;returns&gt;DAO.Recordset&lt;/returns&gt; &lt;remarks&gt;&lt;/remarks&gt; **/</div></div>",84:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype84\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function GetParamDefArray(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ParamArray ParamValues()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Variant</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Erezugt 2-dimensionalen Parameter-Array (z. B. für OpenRecordsetQueryDef) &lt;/summary&gt; &lt;param name=&quot;ParamValues&quot;&gt;Parmeterwerte in passender Reihenfolge (ohne Index-Kennung!)&lt;/param&gt; &lt;returns&gt;DAO.Recordset&lt;/returns&gt; &lt;remarks&gt;&lt;/remarks&gt; **/</div></div>",85:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype85\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function GetNamedParamDefArray(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ParamArray ParamIndexAndValues()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Variant</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Erzeugt 2-dimensionalen Parameter-Array (z. B. für OpenRecordsetQueryDef) &lt;/summary&gt; &lt;param name=&quot;ParamValues&quot;&gt;Parameter-Paare: abwechselnd Parameter-Index und Parameter-Wert&lt;/param&gt; &lt;returns&gt;DAO.Recordset&lt;/returns&gt; &lt;remarks&gt;&lt;/remarks&gt; **/</div></div>",86:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype86\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function OpenRecordsetQueryDefByName(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal QueryName&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal QueryParams&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal RecordsetType&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.RecordsetTypeEnum,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal Options&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.RecordsetOptionEnum,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal LockEdit&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.LockTypeEnum</td></tr></table></td><td class=\"PAfterParameters\">) As DAO.Recordset</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Recordset von gespeicherter Abfrage (optional mit Parametern) öffnen &lt;/summary&gt; &lt;param name=&quot;QueryName&quot;&gt;Name der gespeicherten Abfrage (QueryDef)&lt;/param&gt; &lt;param name=&quot;QueryParams&quot;&gt;2-dimensionales Parameter-Array (Array(n,1) ... x(n,0) = Parametername, x(n,1) = Parameterwert)&lt;/param&gt; &lt;param name=&quot;RecordsetType&quot;&gt;DAO.RecordsetTypeEnum (Standard: dbOpenDynaset)&lt;/param&gt; &lt;param name=&quot;RecordsetOptions&quot;&gt;DAO.RecordsetOptionEnum (Standard: dbSeeChanges)&lt;/param&gt; &lt;param name=&quot;LockEdit&quot;&gt;DAO.LockTypeEnum (Standard: dbOptimistic)&lt;/param&gt; &lt;returns&gt;DAO.Recordset&lt;/returns&gt; &lt;remarks&gt; &lt;/remarks&gt; **/</div></div>",87:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype87\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function OpenRecordsetQueryDef(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal QdfRef&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.QueryDef,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal QdfParamDefs&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal RecordsetType&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.RecordsetTypeEnum,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal Options&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.RecordsetOptionEnum,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal LockEdit&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">DAO.LockTypeEnum</td></tr></table></td><td class=\"PAfterParameters\">) As DAO.Recordset</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Recordset von gespeicherter Abfrage (optional mit Parametern) öffnen &lt;/summary&gt; &lt;param name=&quot;Qdf&quot;&gt;QueryDef-Referenz&lt;/param&gt; &lt;param name=&quot;QueryParams&quot;&gt;2-dimensionales Parameter-Array (Array(n,1) ... x(n,0) = Parametername, x(n,1) = Parameterwert)&lt;/param&gt; &lt;param name=&quot;RecordsetType&quot;&gt;DAO.RecordsetTypeEnum (Standard: dbOpenDynaset)&lt;/param&gt; &lt;param name=&quot;RecordsetOptions&quot;&gt;DAO.RecordsetOptionEnum (Standard: dbSeeChanges)&lt;/param&gt; &lt;param name=&quot;LockEdit&quot;&gt;DAO.LockTypeEnum (Standard: dbOptimistic)&lt;/param&gt; &lt;returns&gt;DAO.Recordset&lt;/returns&gt; &lt;remarks&gt; &lt;/remarks&gt; **/</div></div>",88:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype88\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function LookupSql(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal SqlText&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName\">String,</td><td></td><td class=\"last\"></td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal Index&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName\">Variant</td><td class=\"PDefaultValueSeparator\">&nbsp;=&nbsp;</td><td class=\"PDefaultValue last\"><span class=\"SHNumber\">0</span>&amp;,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal ValueIfNull&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName\">Variant</td><td class=\"PDefaultValueSeparator\">&nbsp;=&nbsp;</td><td class=\"PDefaultValue last\">Null</td></tr></table></td><td class=\"PAfterParameters\">) As Variant</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Lookup-Recordset-Ersatzfunktion für die Übergabe einer vollständigen SQL-Anweisung &lt;/summary&gt; &lt;param name=&quot;SqlText&quot;&gt;SQL-Anweisung&lt;/param&gt; &lt;param name=&quot;Index&quot;&gt;Feldauswahl, falls nicht das erste Feld des Recordsets zurückgegeben werden soll&lt;/param&gt; &lt;param name=&quot;ValueIfNull&quot;&gt;Rückgabewert bei fehlendem Datensatz oder NULL-Feldwert (Standard: Null&lt;/param&gt; &lt;returns&gt;Variant&lt;/returns&gt; &lt;remarks&gt;Die SQL-Anweisung ist im Jet-SQL-Dialekt zu schreiben.&lt;/remarks&gt; **/</div></div>",89:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype89\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function Lookup(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal Expr&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName\">String,</td><td></td><td class=\"last\"></td></tr><tr><td class=\"PModifierQualifier first\">ByVal Domain&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName\">String,</td><td></td><td class=\"last\"></td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal Criteria&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName\">Variant,</td><td></td><td class=\"last\"></td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal ValueIfNull&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName\">Variant</td><td class=\"PDefaultValueSeparator\">&nbsp;=&nbsp;</td><td class=\"PDefaultValue last\">Null</td></tr></table></td><td class=\"PAfterParameters\">) As Variant</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Lookup-Recordset-Ersatzfunktion &lt;/summary&gt; &lt;param name=&quot;Expr&quot;&gt;Feldname oder berechneter Ausdruck (Select-Teil)&lt;/param&gt; &lt;param name=&quot;Domain&quot;&gt;Tabelle, Abfrage oder SQL-Ausdruck für Sub-Abfrage (FROM-Teil)&lt;/param&gt; &lt;param name=&quot;Criteria&quot;&gt;Filter (WHERE-Teil)&lt;/param&gt; &lt;returns&gt;Variant&lt;/returns&gt; &lt;remarks&gt;&lt;/remarks&gt; **/</div></div>",90:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype90\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function Count(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal Expr&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal Domain&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal Criteria&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Long</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; DCount-Recordset-Ersatzfunktion &lt;/summary&gt; &lt;param name=&quot;Expr&quot;&gt;Feldname oder berechneter Ausdruck (Select-Teil)&lt;/param&gt; &lt;param name=&quot;Domain&quot;&gt;Tabelle, Abfrage oder SQL-Ausdruck für Sub-Abfrage (FROM-Teil)&lt;/param&gt; &lt;param name=&quot;Criteria&quot;&gt;Filter (WHERE-Teil)&lt;/param&gt; &lt;returns&gt;Long&lt;/returns&gt; &lt;remarks&gt;&lt;/remarks&gt; **/</div></div>",91:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype91\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function Max(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal Expr&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal Domain&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal Criteria&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Variant</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; DMax-Recordset-Ersatzfunktion &lt;/summary&gt; &lt;param name=&quot;Expr&quot;&gt;Feldname oder berechneter Ausdruck (Select-Teil)&lt;/param&gt; &lt;param name=&quot;Domain&quot;&gt;Tabelle, Abfrage oder SQL-Ausdruck für Sub-Abfrage (FROM-Teil)&lt;/param&gt; &lt;param name=&quot;Criteria&quot;&gt;Filter (WHERE-Teil)&lt;/param&gt; &lt;returns&gt;Variant&lt;/returns&gt; &lt;remarks&gt;&lt;/remarks&gt; **/</div></div>",92:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype92\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function Min(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal Expr&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal Domain&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal Criteria&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Variant</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; DMin-Recordset-Ersatzfunktion &lt;/summary&gt; &lt;param name=&quot;Expr&quot;&gt;Feldname oder berechneter Ausdruck (Select-Teil)&lt;/param&gt; &lt;param name=&quot;Domain&quot;&gt;Tabelle, Abfrage oder SQL-Ausdruck für Sub-Abfrage (FROM-Teil)&lt;/param&gt; &lt;param name=&quot;Criteria&quot;&gt;Filter (WHERE-Teil)&lt;/param&gt; &lt;returns&gt;Variant&lt;/returns&gt; &lt;remarks&gt;&lt;/remarks&gt; **/</div></div>",93:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype93\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function Sum(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal Expr&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal Domain&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal Criteria&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Variant</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; DSum-Recordset-Ersatzfunktion &lt;/summary&gt; &lt;param name=&quot;Expr&quot;&gt;Feldname oder berechneter Ausdruck (Select-Teil)&lt;/param&gt; &lt;param name=&quot;Domain&quot;&gt;Tabelle, Abfrage oder SQL-Ausdruck für Sub-Abfrage (FROM-Teil)&lt;/param&gt; &lt;param name=&quot;Criteria&quot;&gt;Filter (WHERE-Teil)&lt;/param&gt; &lt;returns&gt;Variant&lt;/returns&gt; &lt;remarks&gt;&lt;/remarks&gt; **/</div></div>",94:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype94\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function Exists(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal Domain&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName\">String,</td><td></td><td class=\"last\"></td></tr><tr><td class=\"PModifierQualifier first\">Optional ByVal Criteria&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName\">String</td><td class=\"PDefaultValueSeparator\">&nbsp;=&nbsp;</td><td class=\"PDefaultValue last\">vbNullString</td></tr></table></td><td class=\"PAfterParameters\">) As Boolean</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; DSum-Recordset-Ersatzfunktion &lt;/summary&gt; &lt;param name=&quot;Domain&quot;&gt;Tabelle, Abfrage oder SQL-Ausdruck für Sub-Abfrage (FROM-Teil)&lt;/param&gt; &lt;param name=&quot;Criteria&quot;&gt;Filter (WHERE-Teil)&lt;/param&gt; &lt;returns&gt;Boolean&lt;/returns&gt; &lt;remarks&gt;&lt;/remarks&gt; **/</div></div>",184:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype184\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function InsertIdentityReturn(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal InsertSql&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String</td></tr></table></td><td class=\"PAfterParameters\">) As Variant</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Insert-SQL-Anweisung ausführen und letzten Identity-Wert (Autowert) zurückgeben &lt;/summary&gt; &lt;param name=&quot;InsertSQL&quot;&gt;Insert-SQL-Anweisung (INSERT ...)&lt;/param&gt; &lt;returns&gt;Identity-Wert oder NULL falls kein Datensatz angefügt wurde&lt;/returns&gt; &lt;remarks&gt; Funktioniert erst ab Jet 4.0 (Access 2000) und ist vom DBMS abhängig. Bei MySQL-Tabellen wird z. B. 0 zurückgegeben.&nbsp; (Die &lt;see cref=AdodbHandler#InsertIdentityReturn&gt;ADODB-Variante&lt;/see&gt; dieser Methode ist bezüglich Einsatz für aktive DBMS besser geeignet.)&nbsp; &lt;/remarks&gt; **/</div></div>",185:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype185\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function InsertValues(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal SqlSource&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ParamArray FieldsAndValues()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Boolean</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Recordset öffnen und Werte eines Datensatzes anfügen &lt;/summary&gt; &lt;param name=&quot;SqlSource&quot;&gt;Anfüge-Datenquelle&lt;/param&gt; &lt;param name=&quot;FieldsAndValues&quot;&gt;Auflistung: Feldname1, Wert1, Feldname2, Wert2, .. FeldnameN, WertN&lt;/param&gt; &lt;returns&gt;True, wenn vollständig durchgeführt&lt;/returns&gt; &lt;remarks&gt; Da ein Recordset zum Einfügen verwendet wird, erfolgt im Code keine Datentyp-Prüfung -&gt; auf implizite Konvertierung achten.&nbsp; &lt;/remarks&gt; **/</div></div>",186:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype186\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function InsertValuesReturnFieldValue(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal SqlSource&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal ReturnFieldNameOrIndex&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant,</td></tr><tr><td class=\"PModifierQualifier first\">ParamArray FieldsAndValues()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Variant</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Recordset öffnen und Werte eines Datensatzes anfügen, gibt Wert eine definierten Datenfeldes zurück &lt;/summary&gt; &lt;param name=&quot;SqlSource&quot;&gt;Anfüge-Datenquelle&lt;/param&gt; &lt;param name=&quot;ReturnFieldNameOrIndex&quot;&gt;Datenfeld für Wertrückgabe&lt;/param&gt; &lt;param name=&quot;FieldsAndValues&quot;&gt;Auflistung: Feldname1, Wert1, Feldname2, Wert2, .. FeldnameN, WertN&lt;/param&gt; &lt;returns&gt;Wert aus Datenfeld&lt;/returns&gt; &lt;remarks&gt; Da ein Recordset zum Einfügen verwendet wird, erfolgt im Code keine Datentyp-Prüfung -&gt; auf implizite Konvertierung achten.&nbsp; &lt;/remarks&gt; **/</div></div>",187:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype187\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function NewRecord(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal Source&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal ReturnFieldName&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ParamArray DataParams()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Variant</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Datensatz über Recordset anfügen und Feldwerte einstellen.&nbsp; &lt;/summary&gt; &lt;param name=&quot;Source&quot;&gt;Datenquelle (Tabellenname oder SQL-Anweisung)&lt;/param&gt; &lt;param name=&quot;ReturnFieldName&quot;&gt;Feldname, dessen Wert zurückgegeben werden soll (z. B. Autowert-Feld)&lt;/param&gt; &lt;param name=&quot;DataParams&quot;&gt;Neue Daten ... abwechselnd: Feldname, Feldwert&lt;/param&gt; &lt;returns&gt;Wert aus ReturnFieldName, oder True/False, falls kein ReturnFieldName festgelegt wurde&lt;/returns&gt; &lt;remarks&gt; &lt;/remarks&gt; **/</div></div>",188:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype188\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function CopyRecord(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal Source&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal StartFieldNumber&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Long,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal LastFieldNumber&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Long,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal ReturnFieldName&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ParamArray DataToChange()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Variant</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Datensatz kopieren und einzelne Werte ändern &lt;/summary&gt; &lt;param name=&quot;Source&quot;&gt;Datenquelle (Tabellenname oder SQL-Anweisung)&lt;/param&gt; &lt;param name=&quot;StartFieldNumber&quot;&gt;Datenfeld-Nr. ab der die Daten kopiert werden&lt;/param&gt; &lt;param name=&quot;LastFieldNumber&quot;&gt;Datenfeld-Nr. ab bis zu der die kopiert werden. Ein negativer Wert zähle von hinten.&lt;/param&gt; &lt;param name=&quot;ReturnFieldName&quot;&gt;Feldname, dessen Wert zurückgegeben werden soll (z. B. Autowert-Feld)&lt;/param&gt; &lt;param name=&quot;DataToChange&quot;&gt;zu ändernde Daten ... abwechselnd: Feldname, Feldwert&lt;/param&gt; &lt;returns&gt;Wert aus ReturnFieldName, oder True/False, falls kein ReturnFieldName festgelegt wurde&lt;/returns&gt; &lt;remarks&gt; &lt;/remarks&gt; **/</div></div>",189:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype189\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function CopyRecords(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal SqlSource&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal StartFeldID&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Long,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal LastFeldID&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Long,</td></tr><tr><td class=\"PModifierQualifier first\">ParamArray UpdateFieldsAndValues()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Variant</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Recordset öffnen und Werte eines Datensatzes anfügen &lt;/summary&gt; &lt;param name=&quot;SqlSource&quot;&gt;Anfüge-Datenquelle&lt;/param&gt; &lt;param name=&quot;StartFeldID&quot;&gt;Datenfeld, ab dem kopiert werden soll (z. B. auf 1. Platz ist Autowert =&gt; ab 2 kopieren&lt;/param&gt; &lt;param name=&quot;LastFeldID&quot;&gt;Datenfeld, bis zu dem kopiert werden soll. Soderfälle: 0 = bis zum Ende, negative Wert = ab hinten gezählt&lt;/param&gt; &lt;param name=&quot;UpdateFieldsAndValues&quot;&gt;Auflistung der zu ändernden Felder inkl. deren Werte: Feldname1, Wert1, Feldname2, Wert2, .. FeldnameN, WertN&lt;/param&gt; &lt;returns&gt;True, wenn vollständig durchgeführt&lt;/returns&gt; &lt;remarks&gt; Da ein Recordset zum Einfügen verwendet wird, erfolgt im Code keine Datentyp-Prüfung -&gt; auf implizite Konvertierung achten.&nbsp; &lt;/remarks&gt; **/</div></div>",190:"<div class=\"NDToolTip TFunction LVisualBasic\"><div id=\"NDPrototype190\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\">Public Function CopyRecordsReturnFieldValue(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">ByVal SqlSource&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal StartFeldID&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Long,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal LastFeldID&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Long,</td></tr><tr><td class=\"PModifierQualifier first\">ByVal ReturnField&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">String,</td></tr><tr><td class=\"PModifierQualifier first\">ParamArray UpdateFieldsAndValues()&nbsp;</td><td class=\"PType\">As&nbsp;</td><td class=\"PName last\">Variant</td></tr></table></td><td class=\"PAfterParameters\">) As Variant</td></tr></table></div></div><div class=\"TTSummary\">/** &lt;summary&gt; Datensätze kopieren und Werte ändern &lt;/summary&gt; &lt;param name=&quot;SqlSource&quot;&gt;Anfüge-Datenquelle&lt;/param&gt; &lt;param name=&quot;StartFeldID&quot;&gt;Datenfeld, ab dem kopiert werden soll (z. B. auf 1. Platz ist Autowert =&gt; ab 2 kopieren&lt;/param&gt; &lt;param name=&quot;LastFeldID&quot;&gt;Datenfeld, bis zu dem kopiert werden soll. Soderfälle: 0 = bis zum Ende, negative Wert = ab hinten gezählt&lt;/param&gt; &lt;param name=&quot;ReturnFieldNameOrIndex&quot;&gt;Datenfeld für Wertrückgabe&lt;/param&gt; &lt;param name=&quot;UpdateFieldsAndValues&quot;&gt;Auflistung der zu ändernden Felder inkl. deren Werte: Feldname1, Wert1, Feldname2, Wert2, .. FeldnameN, WertN&lt;/param&gt; &lt;returns&gt;Wert aus Datenfeld&lt;/returns&gt; &lt;remarks&gt; Da ein Recordset zum Einfügen verwendet wird, erfolgt im Code keine Datentyp-Prüfung -&gt; auf implizite Konvertierung achten.&nbsp; &lt;/remarks&gt; **/</div></div>"});