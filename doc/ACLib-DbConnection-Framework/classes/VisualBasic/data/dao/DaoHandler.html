<!DOCTYPE html>

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>DaoHandler</title><link rel="stylesheet" type="text/css" href="../../../../styles/main.css" /><script type="text/javascript" src="../../../../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../../../../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.2 -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');" class="NDPage NDContentPage">

<a name="Topic80"></a><div class="CTopic TClass LVisualBasic first">
 <div class="CTitle"><span class="Qualifier">data.&#8203;dao.</span>&#8203;DaoHandler</div>
 <div class="CBody"><p>DAO data connection methods</p><div class="CHeading">Author</div><p>Josef Poetzl</p></div>
</div>

<a name="Events"></a><a name="Topic81"></a><div class="CTopic TGroup LVisualBasic">
 <div class="CTitle">Events</div>
</div>

<a name="ErrorMissingCurrentDb"></a><a name="Topic82"></a><div class="CTopic TEvent LVisualBasic">
 <div class="CTitle">ErrorMissingCurrentDb</div>
 <div class="CBody"><p>Event for missing CurrentDb reference</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Msg</td><td class="CDLDefinition"><p>Message about the cause of the event triggering. (Not yet used)</p></td></tr><tr><td class="CDLEntry">NewCurrentDbRef</td><td class="CDLDefinition"><p>DAO.Database reference to be used for CurrentDb</p></td></tr></table><div class="CHeading">Remarks</div><p>The required DAO.Database reference can be passed on via the ByRef parameter NewCurrentDbRef.</p></div>
</div>

<a name="Class_control"></a><a name="Topic83"></a><div class="CTopic TGroup LVisualBasic">
 <div class="CTitle">Class control</div>
</div>

<a name="Dispose"></a><a name="Topic84"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">Dispose</div>
 <div id="NDPrototype84" class="NDPrototype"><div class="PSection PPlainSection">Public Sub Dispose()</div></div>
 <div class="CBody"><p>Remove object references</p></div>
</div>

<a name="InitRecordsetEnumDefaultValues"></a><a name="Topic85"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">InitRecordsetEnumDefaultValues</div>
 <div id="NDPrototype85" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Sub InitRecordsetEnumDefaultValues(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">Optional ByRef RecordsetType&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.RecordsetTypeEnum,</td></tr><tr><td class="PModifierQualifier first">Optional ByRef Options&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.RecordsetOptionEnum,</td></tr><tr><td class="PModifierQualifier first">Optional ByRef LockEdit&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.LockTypeEnum</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Set default values for recordset enums, which are used when parameters cannot be set.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">RecordsetType</td><td class="CDLDefinition"><p>DAO.RecordsetTypeEnum</p></td></tr><tr><td class="CDLEntry">Options</td><td class="CDLDefinition"><p>DAO.RecordsetOptionEnum</p></td></tr><tr><td class="CDLEntry">LockEdit</td><td class="CDLDefinition"><p>DAO.LockTypeEnum</p></td></tr></table><div class="CHeading">Remarks</div><p>If 0 is set, standard of DAO is used (0 parameters are passed on to DAO as &quot;IsMissing&quot; variant value).</p></div>
</div>

<a name="Data_Connection"></a><a name="Topic86"></a><div class="CTopic TGroup LVisualBasic">
 <div class="CTitle">Data Connection</div>
</div>

<a name="CurrentDb"></a><a name="Topic87"></a><div class="CTopic TProperty LVisualBasic">
 <div class="CTitle">CurrentDb</div>
 <div class="CBody"><p>CurrentDbC variant</p><div class="CHeading">Returns</div><p>DAO.Database</p><div class="CHeading">Remarks</div><p>CurrentDbC variant which, unlike the original version by Michael Kaplan, does not automatically set the DAO database reference to Access.Application.CurrentDb, but requests it via an event if no reference exists yet.&nbsp; This allows any database reference to be passed via the main application.&nbsp; (e.g. if a temp database is to serve as CurrentDb).</p></div>
</div>

<a name="Data_Operations"></a><a name="Topic88"></a><div class="CTopic TGroup LVisualBasic">
 <div class="CTitle">Data Operations</div>
</div>

<a name="Execute"></a><a name="Topic89"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">Execute</div>
 <div id="NDPrototype89" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function Execute(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Query&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal Options&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.RecordsetOptionEnum</td></tr></table></td><td class="PAfterParameters">) As Long</td></tr></table></div></div>
 <div class="CBody"><p>Execute SQL statement</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">CommandText</td><td class="CDLDefinition"><p>SQL statement (String)</p></td></tr><tr><td class="CDLEntry">Options</td><td class="CDLDefinition"><p>DAO.RecordsetOptionEnum</p></td></tr></table><div class="CHeading">Returns</div><p>RecordsAffected (Long)</p></div>
</div>

<a name="ExecuteParamSQL"></a><a name="Topic90"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">ExecuteParamSQL</div>
 <div id="NDPrototype90" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function ExecuteParamSql(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal SqlText&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ParamArray QueryParams()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Long</td></tr></table></div></div>
 <div class="CBody"><p>Execute SQL statement with parameters</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">SqlText</td><td class="CDLDefinition"><p>SQL statement</p></td></tr><tr><td class="CDLEntry">QueryParams</td><td class="CDLDefinition"><p>Values in suitable order as ParamArray or as array or 2-dimensional parameter array (Array(n,1) ... x(n,0) = parameter name, x(n,1) = parameter value) ... generateable with GetParamDefArray or GetNamedParamDefArray</p></td></tr></table><div class="CHeading">Returns</div><p>RecordsAffected (Long)</p></div>
</div>

<a name="ExecuteQueryDefByName"></a><a name="Topic91"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">ExecuteQueryDefByName</div>
 <div id="NDPrototype91" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function ExecuteQueryDefByName(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal QueryName&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ParamArray QueryParams()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Long</td></tr></table></div></div>
 <div class="CBody"><p>Execute saved query (optionally with parameters)</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">QueryName</td><td class="CDLDefinition"><p>QueryDef name</p></td></tr><tr><td class="CDLEntry">QueryParams</td><td class="CDLDefinition"><p>Values in suitable order as ParamArray or as array or 2-dimensional parameter array (Array(n,1) ... x(n,0) = parameter name, x(n,1) = parameter value) ... generateable with GetParamDefArray or GetNamedParamDefArray</p></td></tr></table><div class="CHeading">Returns</div><p>RecordsAffected (Long)</p></div>
</div>

<a name="ExecuteQueryDef"></a><a name="Topic92"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">ExecuteQueryDef</div>
 <div id="NDPrototype92" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function ExecuteQueryDef(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal QdfRef&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.QueryDef,</td></tr><tr><td class="PModifierQualifier first">ParamArray QueryParams()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Long</td></tr></table></div></div>
 <div class="CBody"><p>Fill QueryDef object with parameter values and then execute it</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">QdfRef</td><td class="CDLDefinition"><p>QueryDef reference</p></td></tr><tr><td class="CDLEntry">QueryParams</td><td class="CDLDefinition"><p>Values in suitable order as ParamArray or as array or 2-dimensional parameter array (Array(n,1) ... x(n,0) = parameter name, x(n,1) = parameter value) ... generateable with GetParamDefArray or GetNamedParamDefArray</p></td></tr></table><div class="CHeading">Returns</div><p>RecordsAffected (Long)</p></div>
</div>

<a name="ParamQueryDefByName"></a><a name="Topic93"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">ParamQueryDefByName</div>
 <div id="NDPrototype93" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function ParamQueryDefByName(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal QueryName&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ParamArray QueryParams()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As DAO.QueryDef</td></tr></table></div></div>
 <div class="CBody"><p>Open saved query as QueryDef object incl. passed parameter values</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">QueryName</td><td class="CDLDefinition"><p>name of query with parameters</p></td></tr><tr><td class="CDLEntry">QueryParams</td><td class="CDLDefinition"><p>Values in suitable order as ParamArray or as array or 2-dimensional parameter array (Array(n,1) ... x(n,0) = parameter name, x(n,1) = parameter value) ... generateable with GetParamDefArray or GetNamedParamDefArray</p></td></tr></table><div class="CHeading">Returns</div><p>DAO.QueryDef</p></div>
</div>

<a name="ParamQueryDefSql"></a><a name="Topic94"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">ParamQueryDefSql</div>
 <div id="NDPrototype94" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function ParamQueryDefSql(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal ParamSqlText&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ParamArray QueryParams()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As DAO.QueryDef</td></tr></table></div></div>
 <div class="CBody"><p>Temporäres QueryDef-Objekt ink. übergebenen Parameterwerten öffnen</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">ParamSqlText</td><td class="CDLDefinition"><p>SQL statement for the temporary QueryDef object</p></td></tr><tr><td class="CDLEntry">QueryParams</td><td class="CDLDefinition"><p>Values in suitable order as ParamArray or as array or 2-dimensional parameter array (Array(n,1) ... x(n,0) = parameter name, x(n,1) = parameter value) ... generateable with GetParamDefArray or GetNamedParamDefArray</p></td></tr></table><div class="CHeading">Returns</div><p>DAO.QueryDef</p></div>
</div>

<a name="OpenRecordset"></a><a name="Topic95"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">OpenRecordset</div>
 <div id="NDPrototype95" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function OpenRecordset(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Source&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName">String,</td><td></td><td class="last"></td></tr><tr><td class="PModifierQualifier first">Optional ByVal RecordsetType&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName">DAO.RecordsetTypeEnum</td><td class="PDefaultValueSeparator">&nbsp;=&nbsp;</td><td class="PDefaultValue last">dbOpenDynaset,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal RecordsetOptions&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName">DAO.RecordsetOptionEnum</td><td class="PDefaultValueSeparator">&nbsp;=&nbsp;</td><td class="PDefaultValue last">DAO.RecordsetOptionEnum.dbSeeChanges,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal LockEdit&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName">DAO.LockTypeEnum</td><td></td><td class="last"></td></tr></table></td><td class="PAfterParameters">) As DAO.Recordset</td></tr></table></div></div>
 <div class="CBody"><p>Open DAO.Recordset</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Source</td><td class="CDLDefinition"><p>SQL statement or table or query name</p></td></tr><tr><td class="CDLEntry">RecordsetType</td><td class="CDLDefinition"><p>DAO.RecordsetTypeEnum (Standard: dbOpenDynaset)</p></td></tr><tr><td class="CDLEntry">RecordsetOptions</td><td class="CDLDefinition"><p>DAO.RecordsetOptionEnum (Standard: dbSeeChanges)</p></td></tr><tr><td class="CDLEntry">LockEdit</td><td class="CDLDefinition"><p>DAO.LockTypeEnum (Standard: dbOptimistic)</p></td></tr></table><div class="CHeading">Returns</div><p>DAO.Recordset</p></div>
</div>

<a name="OpenRecordsetParamSQL"></a><a name="Topic96"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">OpenRecordsetParamSQL</div>
 <div id="NDPrototype96" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function OpenRecordsetParamSql(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal ParamSqlText&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ByVal RecordsetType&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.RecordsetTypeEnum,</td></tr><tr><td class="PModifierQualifier first">ByVal Options&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.RecordsetOptionEnum,</td></tr><tr><td class="PModifierQualifier first">ByVal LockEdit&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.LockTypeEnum,</td></tr><tr><td class="PModifierQualifier first">ParamArray QueryParams()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As DAO.Recordset</td></tr></table></div></div>
 <div class="CBody"><p>Open parameter SQL statement (uses temporary QueryDef)</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">ParamSqlText</td><td class="CDLDefinition"><p>SQL statement with parameters (parameter declaration)</p></td></tr><tr><td class="CDLEntry">RecordsetType</td><td class="CDLDefinition"><p>DAO.RecordsetTypeEnum (Standard: dbOpenDynaset)</p></td></tr><tr><td class="CDLEntry">RecordsetOptions</td><td class="CDLDefinition"><p>DAO.RecordsetOptionEnum (Standard: dbSeeChanges)</p></td></tr><tr><td class="CDLEntry">LockEdit</td><td class="CDLDefinition"><p>DAO.LockTypeEnum (Standard: dbOptimistic)</p></td></tr><tr><td class="CDLEntry">QueryParams</td><td class="CDLDefinition"><p>Values in suitable order as ParamArray or as array or 2-dimensional parameter array (Array(n,1) ... x(n,0) = parameter name, x(n,1) = parameter value) ... generateable with GetParamDefArray or GetNamedParamDefArray</p></td></tr></table><div class="CHeading">Returns</div><p>DAO.Recordset</p></div>
</div>

<a name="OpenRecordsetParamSql2"></a><a name="Topic97"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">OpenRecordsetParamSql2</div>
 <div id="NDPrototype97" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function OpenRecordsetParamSql2(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal ParamSqlText&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ParamArray QueryParams()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As DAO.Recordset</td></tr></table></div></div>
 <div class="CBody"><p>Open parameter SQL statement (like OpenRecordsetParamSQL, but with default values for RecordsetType, RecordsetOptions and LockEdit)</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">ParamSqlText</td><td class="CDLDefinition"><p>SQL statement with parameters (parameter declaration)</p></td></tr><tr><td class="CDLEntry">QueryParams</td><td class="CDLDefinition"><p>Values in suitable order as ParamArray or as array or 2-dimensional parameter array (Array(n,1) ... x(n,0) = parameter name, x(n,1) = parameter value) ... generateable with GetParamDefArray or GetNamedParamDefArray'</p></td></tr></table><div class="CHeading">Returns</div><p>DAO.Recordset</p></div>
</div>

<a name="GetParamDefArray"></a><a name="Topic98"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">GetParamDefArray</div>
 <div id="NDPrototype98" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function GetParamDefArray(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ParamArray ParamValues()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Variant</td></tr></table></div></div>
 <div class="CBody"><p>Creates 2-dimensional parameter array (e.g. for OpenRecordsetQueryDef)</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">ParamValues</td><td class="CDLDefinition"><p>Parmeter values in matching order (without index identifier!)</p></td></tr></table><div class="CHeading">Returns</div><p>Variant (Array)</p></div>
</div>

<a name="GetNamedParamDefArray"></a><a name="Topic99"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">GetNamedParamDefArray</div>
 <div id="NDPrototype99" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function GetNamedParamDefArray(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ParamArray ParamIndexAndValues()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Variant</td></tr></table></div></div>
 <div class="CBody"><p>Creates 2-dimensional parameter array (e.g. for OpenRecordsetQueryDef)</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">ParamValues</td><td class="CDLDefinition"><p>Parameter pairs: alternating parameter index and parameter value</p></td></tr></table><div class="CHeading">Returns</div><p>Variant (Array)</p></div>
</div>

<a name="OpenRecordsetQueryDefByName"></a><a name="Topic100"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">OpenRecordsetQueryDefByName</div>
 <div id="NDPrototype100" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function OpenRecordsetQueryDefByName(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal QueryName&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal QueryParams&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal RecordsetType&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.RecordsetTypeEnum,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal Options&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.RecordsetOptionEnum,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal LockEdit&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.LockTypeEnum</td></tr></table></td><td class="PAfterParameters">) As DAO.Recordset</td></tr></table></div></div>
 <div class="CBody"><p>Open recordset from saved query (optionally with parameters)</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">QueryName</td><td class="CDLDefinition"><p>Name of the saved query</p></td></tr><tr><td class="CDLEntry">QueryParams</td><td class="CDLDefinition"><p>Values in suitable order as ParamArray or as array or 2-dimensional parameter array (Array(n,1) ... x(n,0) = parameter name, x(n,1) = parameter value) ... generateable with GetParamDefArray or GetNamedParamDefArray'</p></td></tr><tr><td class="CDLEntry">RecordsetType</td><td class="CDLDefinition"><p>DAO.RecordsetTypeEnum (Standard: dbOpenDynaset)</p></td></tr><tr><td class="CDLEntry">RecordsetOptions</td><td class="CDLDefinition"><p>DAO.RecordsetOptionEnum (Standard: dbSeeChanges)</p></td></tr><tr><td class="CDLEntry">LockEdit</td><td class="CDLDefinition"><p>DAO.LockTypeEnum (Standard: dbOptimistic)</p></td></tr></table><div class="CHeading">Returns</div><p>DAO.Recordset</p></div>
</div>

<a name="OpenRecordsetQueryDef"></a><a name="Topic101"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">OpenRecordsetQueryDef</div>
 <div id="NDPrototype101" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function OpenRecordsetQueryDef(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal QdfRef&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.QueryDef,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal QueryParams&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal RecordsetType&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.RecordsetTypeEnum,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal RecordsetOptions&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.RecordsetOptionEnum,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal LockEdit&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">DAO.LockTypeEnum</td></tr></table></td><td class="PAfterParameters">) As DAO.Recordset</td></tr></table></div></div>
 <div class="CBody"><p>Recordset von gespeicherter Abfrage (optional mit Parametern) öffnen</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">QdfRef</td><td class="CDLDefinition"><p>QueryDef reference</p></td></tr><tr><td class="CDLEntry">QueryParams</td><td class="CDLDefinition"><p>Values in suitable order as ParamArray or as array or 2-dimensional parameter array (Array(n,1) ... x(n,0) = parameter name, x(n,1) = parameter value) ... generateable with GetParamDefArray or GetNamedParamDefArray'</p></td></tr><tr><td class="CDLEntry">RecordsetType</td><td class="CDLDefinition"><p>DAO.RecordsetTypeEnum (Standard: dbOpenDynaset)</p></td></tr><tr><td class="CDLEntry">RecordsetOptions</td><td class="CDLDefinition"><p>DAO.RecordsetOptionEnum (Standard: dbSeeChanges)</p></td></tr><tr><td class="CDLEntry">LockEdit</td><td class="CDLDefinition"><p>DAO.LockTypeEnum (Standard: dbOptimistic)</p></td></tr></table><div class="CHeading">Returns</div><p>DAO.Recordset</p></div>
</div>

<a name="LookupSQL"></a><a name="Topic102"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">LookupSQL</div>
 <div id="NDPrototype102" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function LookupSql(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal SqlText&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName">String,</td><td></td><td class="last"></td></tr><tr><td class="PModifierQualifier first">Optional ByVal Index&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName">Variant</td><td class="PDefaultValueSeparator">&nbsp;=&nbsp;</td><td class="PDefaultValue last"><span class="SHNumber">0</span>&amp;,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal ValueIfNull&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName">Variant</td><td class="PDefaultValueSeparator">&nbsp;=&nbsp;</td><td class="PDefaultValue last">Null</td></tr></table></td><td class="PAfterParameters">) As Variant</td></tr></table></div></div>
 <div class="CBody"><p>Lookup DAO.Recordset replacement function for DLookup (passing a SQL statement)</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">SqlText</td><td class="CDLDefinition"><p>SQL statement</p></td></tr><tr><td class="CDLEntry">Index</td><td class="CDLDefinition"><p>Field selection if the first field of the recordset is not to be returned.&nbsp; The index is passed in the same way as ADODB.Recordset.Fields(index).</p></td></tr><tr><td class="CDLEntry">ValueIfNull</td><td class="CDLDefinition"><p>Return value if record is missing or data field value is Null (default: Null).</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">Variant</td><td class="CDLDefinition"><p>Null, if SQL statement does not return a record.</p></td></tr></table><div class="CHeading">Remarks</div><p>The SQL statement must be written in the Jet/ACE SQL dialect.</p></div>
</div>

<a name="Lookup"></a><a name="Topic103"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">Lookup</div>
 <div id="NDPrototype103" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function Lookup(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Expr&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName">String,</td><td></td><td class="last"></td></tr><tr><td class="PModifierQualifier first">ByVal Domain&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName">String,</td><td></td><td class="last"></td></tr><tr><td class="PModifierQualifier first">Optional ByVal Criteria&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName">Variant,</td><td></td><td class="last"></td></tr><tr><td class="PModifierQualifier first">Optional ByVal ValueIfNull&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName">Variant</td><td class="PDefaultValueSeparator">&nbsp;=&nbsp;</td><td class="PDefaultValue last">Null</td></tr></table></td><td class="PAfterParameters">) As Variant</td></tr></table></div></div>
 <div class="CBody"><p>DAO.Recordset replacement function for DLookup</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Expr</td><td class="CDLDefinition"><p>Field name or calculated expression (select part)</p></td></tr><tr><td class="CDLEntry">Domain</td><td class="CDLDefinition"><p>Table, query or SQL expression for sub-query (FROM part)</p></td></tr><tr><td class="CDLEntry">Criteria</td><td class="CDLDefinition"><p>(Optional) Criteria string (WHERE part)</p></td></tr><tr><td class="CDLEntry">ValueIfNull</td><td class="CDLDefinition"><p>Return value if record is missing or data field value is Null (default: Null).</p></td></tr></table><div class="CHeading">Returns</div><p>Variant</p></div>
</div>

<a name="Count"></a><a name="Topic104"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">Count</div>
 <div id="NDPrototype104" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function Count(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Expr&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ByVal Domain&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal Criteria&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Long</td></tr></table></div></div>
 <div class="CBody"><p>DAO.Recordset replacement function for DCount</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Expr</td><td class="CDLDefinition"><p>Field name or calculated expression (select part)</p></td></tr><tr><td class="CDLEntry">Domain</td><td class="CDLDefinition"><p>Table, query or SQL expression for sub-query (FROM part)</p></td></tr><tr><td class="CDLEntry">Criteria</td><td class="CDLDefinition"><p>(optional) Criteria string (WHERE part)</p></td></tr></table><div class="CHeading">Returns</div><p>Long</p></div>
</div>

<a name="Max"></a><a name="Topic105"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">Max</div>
 <div id="NDPrototype105" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function Max(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Expr&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ByVal Domain&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal Criteria&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Variant</td></tr></table></div></div>
 <div class="CBody"><p>DAO.Recordset replacement function for DMax</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Expr</td><td class="CDLDefinition"><p>Field name or calculated expression (select part)</p></td></tr><tr><td class="CDLEntry">Domain</td><td class="CDLDefinition"><p>Table, query or SQL expression for sub-query (FROM part)</p></td></tr><tr><td class="CDLEntry">Criteria</td><td class="CDLDefinition"><p>(Optional) Criteria string (WHERE part)</p></td></tr></table><div class="CHeading">Returns</div><p>Variant</p></div>
</div>

<a name="Min"></a><a name="Topic106"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">Min</div>
 <div id="NDPrototype106" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function Min(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Expr&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ByVal Domain&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal Criteria&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Variant</td></tr></table></div></div>
 <div class="CBody"><p>DAO.Recordset replacement function for DMin</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Expr</td><td class="CDLDefinition"><p>Field name or calculated expression (select part)</p></td></tr><tr><td class="CDLEntry">Domain</td><td class="CDLDefinition"><p>Table, query or SQL expression for sub-query (FROM part)</p></td></tr><tr><td class="CDLEntry">Criteria</td><td class="CDLDefinition"><p>(Optional) Criteria string (WHERE part)</p></td></tr></table><div class="CHeading">Returns</div><p>Variant</p></div>
</div>

<a name="Sum"></a><a name="Topic107"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">Sum</div>
 <div id="NDPrototype107" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function Sum(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Expr&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ByVal Domain&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">Optional ByVal Criteria&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Variant</td></tr></table></div></div>
 <div class="CBody"><p>DAO.Recordset replacement function for DSum</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Expr</td><td class="CDLDefinition"><p>Field name or calculated expression (select part)</p></td></tr><tr><td class="CDLEntry">Domain</td><td class="CDLDefinition"><p>Table, query or SQL expression for sub-query (FROM part)</p></td></tr><tr><td class="CDLEntry">Criteria</td><td class="CDLDefinition"><p>(Optional) Criteria string (WHERE part)</p></td></tr></table><div class="CHeading">Returns</div><p>Variant</p></div>
</div>

<a name="Exists"></a><a name="Topic108"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">Exists</div>
 <div id="NDPrototype108" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function Exists(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Domain&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName">String,</td><td></td><td class="last"></td></tr><tr><td class="PModifierQualifier first">Optional ByVal Criteria&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName">String</td><td class="PDefaultValueSeparator">&nbsp;=&nbsp;</td><td class="PDefaultValue last">vbNullString</td></tr></table></td><td class="PAfterParameters">) As Boolean</td></tr></table></div></div>
 <div class="CBody"><p>Check if record exists</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Domain</td><td class="CDLDefinition"><p>data source (FROM part)</p></td></tr><tr><td class="CDLEntry">Criteria</td><td class="CDLDefinition"><p>(Optional) Criteria string (WHERE part)</p></td></tr></table><div class="CHeading">Returns</div><p>Boolean</p></div>
</div>

<a name="InsertIdentityReturn"></a><a name="Topic109"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">InsertIdentityReturn</div>
 <div id="NDPrototype109" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function InsertIdentityReturn(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal InsertSql&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String</td></tr></table></td><td class="PAfterParameters">) As Variant</td></tr></table></div></div>
 <div class="CBody"><p>Execute insert SQL statement and return last identity value (auto value)</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">InsertSQL</td><td class="CDLDefinition"><p>Insert SQL statement</p></td></tr></table><div class="CHeading">Returns</div><p>Identity value or NULL if no record was appended</p><div class="CHeading">Remarks</div><p>Works for Jet only from Jet 4.0 (Access 2000), IdentityTable is only applicable for MSSQL, under MySQL the IDENT_CURRENT function does not exist.&nbsp; (<a href="../../../../index.html#VisualBasicClass:data.adodb.AdodbHandler:InsertIdentityReturn" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,41);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >data.adodb.AdodbHandler::InsertIdentityReturn</a> is more suitable regarding use for active DBMS.)</p></div>
</div>

<a name="InsertValues"></a><a name="Topic110"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">InsertValues</div>
 <div id="NDPrototype110" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function InsertValues(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Source&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ParamArray FieldsAndValues()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Boolean</td></tr></table></div></div>
 <div class="CBody"><p>Open recordset and append values</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Source</td><td class="CDLDefinition"><p>Insert data source</p></td></tr><tr><td class="CDLEntry">FieldsAndValues</td><td class="CDLDefinition"><p>ParamArray: &quot;Field1&quot;, Value1, &quot;Field2&quot;, Value2, ....</p></td></tr></table><div class="CHeading">Returns</div><p>True if fully executed</p><div class="CHeading">Remarks</div><p>Since a recordset is used for insertion, there is no data type check in the code -&gt; watch out for implicit conversion.</p></div>
</div>

<a name="InsertValuesReturnFieldValue"></a><a name="Topic111"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">InsertValuesReturnFieldValue</div>
 <div id="NDPrototype111" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function InsertValuesReturnFieldValue(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Source&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ByVal ReturnFieldNameOrIndex&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant,</td></tr><tr><td class="PModifierQualifier first">ParamArray FieldsAndValues()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Variant</td></tr></table></div></div>
 <div class="CBody"><p>Ropen ecordset and append values, returns value of a defined data field</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Source</td><td class="CDLDefinition"><p>Insert data source</p></td></tr><tr><td class="CDLEntry">ReturnFieldNameOrIndex</td><td class="CDLDefinition"><p>Datenfeld für Wertrückgabe&lt;/param&gt;</p></td></tr><tr><td class="CDLEntry">FieldsAndValues</td><td class="CDLDefinition"><p>ParamArray: &quot;Field1&quot;, Value1, &quot;Field2&quot;, Value2, ....</p></td></tr></table><div class="CHeading">Returns</div><p>Value from data field</p><div class="CHeading">Remarks</div><p>Since a recordset is used for insertion, there is no data type check in the code -&gt; watch out for implicit conversion.</p></div>
</div>

<a name="NewRecord"></a><a name="Topic112"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">NewRecord</div>
 <div id="NDPrototype112" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function NewRecord(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Source&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ByVal ReturnFieldName&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ParamArray FieldsAndValues()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Variant</td></tr></table></div></div>
 <div class="CBody"><p>Append record via recordset and set field values.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Source</td><td class="CDLDefinition"><p>Data source (table name or SQL statement)</p></td></tr><tr><td class="CDLEntry">ReturnFieldName</td><td class="CDLDefinition"><p>Field name whose value is to be returned (e.g. autonumber field).</p></td></tr><tr><td class="CDLEntry">FieldsAndValues</td><td class="CDLDefinition"><p>new data ... ParamArray: &quot;Field1&quot;, Value1, &quot;Field2&quot;, Value2, ....</p></td></tr></table><div class="CHeading">Returns</div><p>Value from ReturnFieldName, or True/False if no ReturnFieldName was specified.</p></div>
</div>

<a name="CopyRecord"></a><a name="Topic113"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">CopyRecord</div>
 <div id="NDPrototype113" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function CopyRecord(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Source&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ByVal StartFieldNumber&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Long,</td></tr><tr><td class="PModifierQualifier first">ByVal LastFieldNumber&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Long,</td></tr><tr><td class="PModifierQualifier first">ByVal ReturnFieldName&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ParamArray DataToChange()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Variant</td></tr></table></div></div>
 <div class="CBody"><p>Copy data set and change individual values</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Source</td><td class="CDLDefinition"><p>Data source (table name or SQL statement)</p></td></tr><tr><td class="CDLEntry">StartFieldNumber</td><td class="CDLDefinition"><p>Data field number (=field index+1) from which the data is copied</p></td></tr><tr><td class="CDLEntry">LastFieldNumber</td><td class="CDLDefinition"><p>Data field number (=field index+1) up to which the data are copied. A negative value counts from behind.</p></td></tr><tr><td class="CDLEntry">ReturnFieldName</td><td class="CDLDefinition"><p>Field name whose value is to be returned (e.g. auto number field).</p></td></tr><tr><td class="CDLEntry">DataToChange</td><td class="CDLDefinition"><p>data to be changed ... alternating: field name, field value - ParamArray: &quot;Field1&quot;, Value1, &quot;Field2&quot;, Value2, ....</p></td></tr></table><div class="CHeading">Returns</div><p>Value from ReturnFieldName, or True/False if no ReturnFieldName was specified.</p></div>
</div>

<a name="CopyRecords"></a><a name="Topic114"></a><div class="CTopic TFunction LVisualBasic">
 <div class="CTitle">CopyRecords</div>
 <div id="NDPrototype114" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function CopyRecords(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Source&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ByVal StartFieldNumber&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Long,</td></tr><tr><td class="PModifierQualifier first">ByVal LastFieldNumber&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Long,</td></tr><tr><td class="PModifierQualifier first">ParamArray DataToChange()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Boolean</td></tr></table></div></div>
 <div class="CBody"><p>Recordset öffnen und Werte eines Datensatzes anfügen</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Source</td><td class="CDLDefinition"><p>Data source (table name or SQL statement)</p></td></tr><tr><td class="CDLEntry">StartFieldNumber</td><td class="CDLDefinition"><p>Data field number (=field index+1) from which the data is copied</p></td></tr><tr><td class="CDLEntry">LastFieldNumber</td><td class="CDLDefinition"><p>Data field number (=field index+1) up to which the data are copied. A negative value counts from behind.</p></td></tr><tr><td class="CDLEntry">DataToChange</td><td class="CDLDefinition"><p>data to be changed ... alternating: field name, field value - ParamArray: &quot;Field1&quot;, Value1, &quot;Field2&quot;, Value2, ....</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">Boolean</td><td class="CDLDefinition"><p>True if success</p></td></tr></table><div class="CHeading">Remarks</div><p>Since a recordset is used for insertion, there is no data type check in the code -&gt; watch out for implicit conversion.</p></div>
</div>

<a name="CopyRecordsReturnFieldValue"></a><a name="Topic115"></a><div class="CTopic TFunction LVisualBasic last">
 <div class="CTitle">CopyRecordsReturnFieldValue</div>
 <div id="NDPrototype115" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">Public Function CopyRecordsReturnFieldValue(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">ByVal Source&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ByVal StartFieldNumber&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Long,</td></tr><tr><td class="PModifierQualifier first">ByVal LastFieldNumber&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Long,</td></tr><tr><td class="PModifierQualifier first">ByVal ReturnFieldName&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">String,</td></tr><tr><td class="PModifierQualifier first">ParamArray DataToChange()&nbsp;</td><td class="PType">As&nbsp;</td><td class="PName last">Variant</td></tr></table></td><td class="PAfterParameters">) As Variant</td></tr></table></div></div>
 <div class="CBody"><p>/** &lt;summary&gt; Datensätze kopieren und Werte ändern</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">Source</td><td class="CDLDefinition"><p>Data source (table name or SQL statement)</p></td></tr><tr><td class="CDLEntry">StartFieldNumber</td><td class="CDLDefinition"><p>Data field number (=field index+1) from which the data is copied</p></td></tr><tr><td class="CDLEntry">LastFieldNumber</td><td class="CDLDefinition"><p>Data field number (=field index+1) up to which the data are copied. A negative value counts from behind.</p></td></tr><tr><td class="CDLEntry">ReturnFieldName</td><td class="CDLDefinition"><p>Field name whose value is to be returned (e.g. auto number field).</p></td></tr><tr><td class="CDLEntry">DataToChange</td><td class="CDLDefinition"><p>data to be changed ... alternating: field name, field value - ParamArray: &quot;Field1&quot;, Value1, &quot;Field2&quot;, Value2, ....</p></td></tr></table><div class="CHeading">Returns</div><p>Value from ReturnFieldName, or True/False if no ReturnFieldName was specified.</p><div class="CHeading">Remarks</div><p>Since a recordset is used for insertion, there is no data type check in the code -&gt; watch out for implicit conversion.</p></div>
</div>

</body></html>